# Константин Сахаров, 18-я когорта — Финальный проект. Инженер по тестированию плюс

import requests
import configuration
import data
import sender_stand_request


# Функция получения трека нового заказа
# Обращается к функции создания заказа (которая осталась в другом файле) с параметром, взятым из файла data
# Тело полученного от сервера ответа (об успешном создании заказа) функция записывает в свою внутреннюю переменную.
# Из этой переменной функция берёт значение ключа track и записывает его в ещё одну внутреннюю переменную.
# Значение этой второй внутренней переменной функция возвращает наружу.
def get_new_order_track():
    new_order_response = sender_stand_request.create_new_order(data.new_order_body)
    new_track = new_order_response.json()["track"]
    return new_track


# Теперь запишем значение трека во внешнюю (относительно функции) переменную track.
# Переменные new_order_response и new_track остаются только внутри функции get_new_order_track.

track = get_new_order_track()
# Можно показать, какое значение получила переменная
print(track)


# Функция получения данных заказа по треку имеющегося заказа.
# У неё есть параметр, в него она будет получать свежесозданный номер трека
def get_order_data_by_track(ordertrack):
    return requests.get(configuration.URL_SERVICE + configuration.GET_ORDER_DATA_BY_TRACK + str(ordertrack))

# Функция get_order_data_by_track получает ответ сервера: данные заказа.
# В нём есть заголовок (200 при успехе), а также тело, в котором все поля таблицы Orders


# Временная переменная для проверки, работает ли функция
# При тесте функция будет примерно так же вызываться внутри функции позитивной проверки или прямо внутри теста
get_order_data_by_track_response = get_order_data_by_track(track)
# Можно показать, какой ответ от сервера получился
print(get_order_data_by_track_response.status_code)
print(get_order_data_by_track_response.json())


# Функция для позитивной проверки. Без параметра, потому что на вход она будет получать одни и те же данные
# и сгенерированный при создании нового заказа трек.
# Тестировщик не передаёт функции какие-то определённые тестовые данные.
# Функция ничего не возвращает, только делает assert.
def positive_assert():
    # Чтобы сохранить значение во внутреннюю переменную, делается вот что:
    # Вызывается Функция получения данных заказа по треку имеющегося заказа.
    # В качестве параметра у неё — переменная track.
    # Ранее мы задали, что значение переменной track — результат выполнения Функция получения трека нового заказа.
    # Функция get_new_order_track() выполнилась, вернула значение трека и записала его в глобальную переменную track.
    # Теперь значение глобальной берёт функция get_order_data_by_track, обращается с ним к серверу и получает ответ.
    # У ответа сервера есть статус-код,
    # его-то мы и присвоим внутренней переменной check_response в функции позитивной проверки.
    check_response = get_order_data_by_track(track).status_code
    # Проверяется, что код ответа равен 200
    assert check_response == 200
    # Можно убедиться, что при другом сравенении тест провалится:
    # assert check_response == 100


# Тест получения кода 200 при запросе данных заказа по треку
def test1_response_200_while_getting_order_data_by_track_after_creating_new_order():
    positive_assert()


# Вариант того же теста без использования промежуточной функции позитивной проверки.
# Подойдёт, если сьют не планируется сильно масштабировать.
# На случай же появления разнообразных тестов, например с разными входными данными для заказов, лучше иметь отдельную
# функцию позитивной проверки (а вдобавок ещё и негативную).
def test2_response_200_while_getting_order_data_by_track_after_creating_new_order_without_positive_assert():
    assert get_order_data_by_track(track).status_code == 200
